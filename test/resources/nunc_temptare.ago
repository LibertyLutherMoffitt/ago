(
satus []                            // method name and list of function parametrs; [] = 0 params
    (                               // start of the let block
        [                           // start of the let declaration block
            xa      II              // xa = 2 (-a = int)
            yae     -1.2            // yae = -1.2 (-ae = float)
            _       ()lego          // read a line and a throw it away
            werum   ((()lego)tondeo ", ")decido     // read a line, trim, then split it into a list on ", ", and place it into "werum", erum = list of strings
            wer2um  (               // same but with the -> syntax for readiblity
                ()lego
                tondeo              
                (", ")decido        
            )->                     // this is clojure style function which takes the return of the previous function, and makes it be the first param of the next function
        ]
                                    // start of the let body

        (                           // start of the for loop
            [ies  werum[(0 -II)..]]    // ies = iterator, -es = string, slice: werum[0:-2], (0 -II).. returns a slice object

            (                   // if function
             ((ia I)^ 0)>       (ies)dixit      // if multiple statements in body you can use [] surrounding the body
            )si

            (
             ((iae -.1)+ 0)>    (ies)dixit      // if: print
             (iam falsus)et     ()pergo         // elif: continue
             ()frio                             // else: break
            )si                                 

        )pro
        
        (werum[0] verum)?:                      // automatically returns the final thing in the let statement
                                                // automatically returns the final thing in the method
        
    )sino
)des
