# Ago Standard Library Prelude
# These functions are automatically available in all Ago programs.


# abba - returns int absolute value
# Name ends in -a (returns int)
des abba ( xa ) {
    si xa < 0 {
        redeo -xa
    } aluid {
        redeo xa
    }
}

# appendum - appends yium to xium
# Name ends in -uum (returns list_any)
des appenduum (xuum, yium) {
    lengtha := xuum.a()
    inseri(xuum, lengtha, yium)
    redeo xuum
}

# vicissuum - reverse list_any
# Name ends in -uum (returns list_any)
des vicissuum( ruum ) {
    tuum := []
    pro dium in ruum {
        inseri(tuum, 0, dium)
    }
    redeo tuum
}

# spoliares - functions like python "strip" function, 
# removes white space from string and returns a new string
# Name ends in -es (returns string)
des spoliares(ses) {
    xes := ""
    vexillam := falsus

    pro yes in serum {
        si vexillam {
            xes = xes + yes
        } aluid {
            vexillam = (yes != " " et yes != "\n" et yes != "\t")
            si vexillam {
                xes = xes + yes
            }
        }
    }

    cerum := xerum
    lengtha := ca
    
    vexillam = falsus
    zes := ""
    pro ia in 1..lengtha {
        pia := lengtha - ia
        si vexillam {
            zes = xes[pia] + zes
        } aluid {
            vexillam = (xes[pia] != " " et xes[pia] != "\n" et xes[pia] != "\t")
            si vexillam {
                zes = xes[pia] + zes
            }
        }
    }
    redeo zes
}

# digitam - takes a string, returns Verum if all of the contents 
# are digits and Falsus otherwise.
# Name ends in -am (returns bool)
des digitam(ses) {
    digitserum := ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
    pro xes in serum {
        vexillam := falsus
        pro zes in digitserum {
            si xes == zes {
                vexillam = verum
            }
        }
        si non vexillam {
            redeo falsus
        }
    }
    redeo verum
}

# iunges - join a list of strings with "
# name ends in -es (returns string)
des iunges(lerum, ses) {
    res := lerum[0]
    vexillam := falsus
    pro xes in lerum {
        si vexillam {
            res = res + ses + xes
        } aluid {
            vexillam = non vexillam
        }
    }
    redeo res
}

# liquum - Filter a list, returning elements where predicate returns true
# Takes a list and a predicate lambda, returns a new list with matching elements
# Name ends in -uum (returns list_any)
des liquum(luum, xo) {
    ia := 0
    dum ia < la {
        si non xo(luum[ia]) {
            luum.removium(ia)
        } aluid {
            ia = ia + 1
        }
    }
    redeo luum
}

# plicium - Fold/reduce a list using a binary function
# Takes a list and a binary lambda (accumulator, element) -> new_accumulator
# Returns inanis for empty lists, otherwise reduces left-to-right using first element as initial value
des plicium(luum, xo) {
    si non lam {
        redeo inanis
    }

    aium := luum[0]
    pro lium in luum[1..la] {
        aium = xo(aium, lium)
    }
    redeo aium
}

# mutatuum - Maps a list to a new list, returning elements modified by function xo
# Takes a list and a predicate lambda, returns a new list with modified elements
# Name ends in -uum (returns list_any)
des mutatuum(luum, xo) {
    pro xa in le { luum[xa] = xo(luum[xa]) }
    redeo luum
}

# minium - Returns the minimum element of any list
# Works with all list types containing comparable elements
# Returns inanis for empty lists
des minium(luum) {
    redeo luum.plicium(des (aium, bium) {aium < bium ? aium : bium})
}

# maxium - Returns the maximum element of any list
# Works with all list types containing comparable elements
# Returns inanis for empty lists
des maxium(luum) {
    redeo luum.plicium(des (aium, bium) {aium > bium ? aium : bium})
}
