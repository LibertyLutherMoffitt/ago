# Ago Standard Library Prelude
# These functions are automatically available in all Ago programs.


# sqrtae - returns the square root of sium
# Name ends in -tae (returns int/float)
des sqrtae(sium) {
    subtilita := 0

    si sium < MMM {
        subtilita = XIII
    } aluid sium < powa(X, V) {
        subtilita = XIII
    } aluid sium < powa(X, VIII) {
        subtilita = MXXIV
    } aluid sium < powa(X, IX) {
        subtilita = MMXLVIII
    } aluid {
        subtilita = MMXLVIII * III
    }

    xium := sium / 2

    pro ia in 0..subtilita {
        xium = 0.5 * (xium + (sium / xium))
    }
    redeo xium
}

# powa - returns xa to the na power
# Name ends in -a (returns int)
des powa(xa, na) {
    ra := 1
    pro ia in 0..na {
        ra = ra * xa
    }
    redeo ra
}

# abbium - returns absolute value
# Name ends in -ium (returns int/float)
des abbium(xium) {
    redeo xium < 0  ? -xium : xium
}

# appenduum - appends yium to xium
# Name ends in -uum (returns list_any)
des appenduum(xuum, yium) {
    xuum.inseri(xa, yium)
    redeo xuum
}

# vicissuum - reverse list_any
# Name ends in -uum (returns list_any)
des vicissuum(ruum) {
    tuum := []
    ia := ra
    dum ia > 0 {
        ia = ia - I
        tuum.inseri(ta, ruum[ia]) 
    }
    redeo tuum
}

# spoliares - functions like python "strip" function,
# removes white space from string and returns a new string
# Name ends in -es (returns string)
des spoliares(ses) {
    xes := ""
    vexillam := falsus

    pro yes in serum {
        si vexillam {
            xes = xes + yes
        } aluid {
            vexillam = (yes != " " et yes != "\n" et yes != "\t")
            si vexillam {
                xes = xes + yes
            }
        }
    }

    cerum := xerum
    lengtha := ca

    vexillam = falsus
    zes := ""
    pro ia in 1..lengtha {
        pia := lengtha - ia
        si vexillam {
            zes = xes[pia] + zes
        } aluid {
            vexillam = (xes[pia] != " " et xes[pia] != "\n" et xes[pia] != "\t")
            si vexillam {
                zes = xes[pia] + zes
            }
        }
    }
    redeo zes
}

# digitam - takes a string, returns Verum if all of the contents
# are digits and Falsus otherwise.
# Name ends in -am (returns bool)
des digitam(ses) {
    digitserum := ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
    pro xes in serum {
        vexillam := falsus
        pro zes in digitserum {
            si xes == zes {
                vexillam = verum
                frio
            }
        }
        si non vexillam {
            redeo falsus
        }
    }
    redeo verum
}

# iunges - join a list of strings with a separator
# Takes a StringList and separator string, returns joined string
# Name ends in -es (returns string)
des iunges(lerum, ses) {
    res := lerum[0]
    vexillam := falsus
    pro xes in lerum {
        si vexillam {
            res = res + ses + xes
        } aluid {
            vexillam = non vexillam
        }
    }
    redeo res
}

# liquum - Filter a list, returning elements where predicate returns true
# Takes a list and a predicate lambda, returns a new list with matching elements
# Name ends in -uum (returns list_any)
# Optimized: builds new list O(n) instead of in-place removal O(nÂ²)
des liquum(luum, xo) {
    ruum := []
    pro lium in luum {
        si xo(lium) {
            ruum.inseri(ra, lium)
        }
    }
    redeo ruum
}

# plicium - Fold/reduce a list using a binary function
# Takes a list and a binary lambda (accumulator, element) -> new_accumulator
# Returns inanis for empty lists, otherwise reduces left-to-right using first element as initial value
des plicium(luum, xo) {
    si non lam {
        redeo inanis
    }

    aium := luum[0]
    pro lium in luum[1..la] {
        aium = xo(aium, lium)
    }
    redeo aium
}

# mutatuum - Maps a list to a new list, returning elements modified by function xo
# Takes a list and a predicate lambda, returns a new list with modified elements
# Name ends in -uum (returns list_any)
des mutatuum(luum, xo) {
    pro xa in le { luum[xa] = xo(luum[xa]) }
    redeo luum
}

# minium - Returns the minimum element of any list
# Works with all list types containing comparable elements
# Returns inanis for empty lists
des minium(luum) {
    redeo luum.plicium(des (aium, bium) {aium < bium ? aium : bium})
}

# maxium - Returns the maximum element of any list
# Works with all list types containing comparable elements
# Returns inanis for empty lists
des maxium(luum) {
    redeo luum.plicium(des (aium, bium) {aium > bium ? aium : bium})
}

# finderum - Split a string on a single character separator
# Takes a string and separator, returns list of substrings
# Name ends in -erum (returns StringList)
des finderum(les, ses) {
    rerum := []
    ba := 0
    ea := 0
    dum ea < lerum.a() {
        si ses == les[ea] {
            si ba < ea {
                rerum.inseri(rerum.a(), les[ba.<ea])
            }
            ba = ea + 1
        }
        ea = ea + 1
    }
    si ba < ea {
        rerum.inseri(rerum.a(), les[ba.<ea])
    }
    redeo rerum
}

# findomnerum - Split a string on a single character separator
# Takes a string and separator, returns list of substrings
# Returns "" as well when separators are adjacent
# Name ends in -erum (returns StringList)
des findomnerum(les, ses) {
    rerum := []
    ba := 0
    ea := 0
    dum ea < lerum.a() {
        si ses == les[ea] {
            si ba <= ea {
                rerum.inseri(rerum.a(), les[ba.<ea])
            }
            ba = ea + 1
        }
        ea = ea + 1
    }
    si ba <= ea {
        rerum.inseri(rerum.a(), les[ba.<ea])
    }
    redeo rerum
}

# sumium - Sum all elements of a numeric list
# Returns the sum of all elements, or inanis for empty lists
# Name ends in -ium (returns int/float/any)
des sumium(luum) {
    redeo luum.plicium(des (aium, bium) {aium + bium})
}

# prodium - Product of all elements of a numeric list
# Returns the product of all elements, or inanis for empty lists
# Name ends in -ium (returns int/float/any)
des prodium(luum) {
    redeo luum.plicium(des (aium, bium) {aium * bium})
}

# invena - Find the index of an element in a list
# Returns the first index where the element is found, or inanis if not found
# Name ends in -a (returns int)
des invena(luum, xium) {
    pro ia in le {
        si luum[ia] == xium {
            redeo ia
        }
    }
}

# _conuum - Internal merge function for merge sort
# Merges two sorted lists using comparison function xo
# Uses inseri for in-place building of result list
# Name ends in -uum (returns list_any)
des _conuum(auum, buum, xo) {
    ruum := []
    aia := 0
    bia := 0
    dum aia < aa et bia < ba {
        si xo(auum[aia]) < xo(buum[bia]) {
            ruum.inseri(ra, auum[aia])
            aia = aia + 1
        } aluid {
            ruum.inseri(ra, buum[bia])
            bia = bia + 1
        }
    }
    dum aia < aa {
        ruum.inseri(ra, auum[aia])
        aia = aia + 1
    }
    dum bia < ba {
        ruum.inseri(ra, buum[bia])
        bia = bia + 1
    }
    redeo ruum
}

# genorduum - Merge sort a list using comparison function xo
# Takes a list and a key function that extracts the sort key from each element
# Returns a new sorted list
# Name ends in -uum (returns list_any)
des genorduum(luum, xo) {
    si la <= 1 { redeo luum }
    redeo _conuum(genorduum(luum[0.<la/2], xo), genorduum(luum[la/2.<la], xo), xo)
}

# ullam - any
des ullam(luum, xo) {
    pro lium in luum { si xo(lium) { redeo verum } }
    redeo falsus
}

# omnam - all
des omnam(luum, xo) {
    redeo non luum.ullam(des{ non xo(id) })
}

# nullam - none
des nullam(luum, xo) {
    redeo non luum.ullam(xo)
}

